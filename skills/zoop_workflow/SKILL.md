# Zoop Workflow Skill

**Auto-loaded when**: Working with zoop source files, WebIDL bindings, or class definitions

---

## Critical Rules

### üö´ NEVER Edit Generated Files

**NEVER edit files in `src/` that were generated by zoop-codegen.**

Generated files have this header:
```zig
// Auto-generated by zoop-codegen
// DO NOT EDIT - changes will be overwritten
```

**Why**: Any changes will be **overwritten** on the next build. Your work will be lost.

**Always edit**: `zoop_src/` files (the source of truth)

---

## Directory Structure

```
project/
‚îú‚îÄ‚îÄ zoop_src/                  # ‚úÖ EDIT THESE - Source of truth
‚îÇ   ‚îú‚îÄ‚îÄ text_encoder.zig       # Zoop class definitions
‚îÇ   ‚îî‚îÄ‚îÄ text_encoder_common.zig # Zoop mixin definitions
‚îÇ
‚îú‚îÄ‚îÄ src/                       # ‚ùå DO NOT EDIT - Auto-generated
‚îÇ   ‚îú‚îÄ‚îÄ text_encoder.zig       # Generated from zoop_src/text_encoder.zig
‚îÇ   ‚îî‚îÄ‚îÄ text_encoder_common.zig # Generated from zoop_src/text_encoder_common.zig
‚îÇ
‚îú‚îÄ‚îÄ .zig-cache/
‚îÇ   ‚îî‚îÄ‚îÄ zoop-manifest.json     # Cache (gitignored)
‚îÇ
‚îî‚îÄ‚îÄ build.zig                  # Includes zoop codegen step
```

---

## Workflow

### 1. Edit Zoop Source Files

**Location**: `zoop_src/*.zig`

**Example** (`zoop_src/text_encoder.zig`):
```zig
const std = @import("std");
const zoop = @import("zoop");

pub const TextEncoder = zoop.class(struct {
    allocator: std.mem.Allocator,

    pub fn init(allocator: std.mem.Allocator) TextEncoder {
        return .{
            .allocator = allocator,
        };
    }

    pub fn encode(self: *TextEncoder, input: []const u8) ![]u8 {
        // Your implementation here
        return self.allocator.dupe(u8, input);
    }
});
```

### 2. Build (Auto-Regenerates)

```bash
zig build
```

**What happens**:
1. Zoop-codegen scans `zoop_src/`
2. Detects changes via cache (SHA-256 hash)
3. Regenerates only changed files in `src/`
4. Compiles against generated `src/` files

**Output**:
```
[zoop-codegen] Scanning zoop_src for class definitions...
  Generated: text_encoder.zig

Processed 1 files, generated 1 class files
[zoop-codegen] ‚úì Generated classes in src
```

### 3. Review Generated Files (Optional)

```bash
cat src/text_encoder.zig
```

**Generated file** (`src/text_encoder.zig`):
```zig
// Auto-generated by zoop-codegen
// DO NOT EDIT - changes will be overwritten

const std = @import("std");

pub const TextEncoder = struct {
    allocator: std.mem.Allocator,

    pub fn init(allocator: std.mem.Allocator) TextEncoder {
        return .{
            .allocator = allocator,
        };
    }

    pub fn encode(self: *TextEncoder, input: []const u8) ![]u8 {
        return self.allocator.dupe(u8, input);
    }
};
```

**Notice**: Zoop stripped the `zoop.class()` wrapper and produced a plain Zig struct.

### 4. Test

```bash
zig build test
```

**Tests run against**: Generated `src/` files (not `zoop_src/`)

### 5. Commit Both Source and Generated

```bash
git add zoop_src/text_encoder.zig
git add src/text_encoder.zig
git commit -m "Add TextEncoder.encode() implementation"
```

**Why commit generated files?**
- Consumers see stable, reviewed code
- PRs show exactly what code changes
- No codegen step needed for consumers
- Easier debugging (inspect generated code)

---

## Zoop Class Syntax

### Basic Class

```zig
const std = @import("std");
const zoop = @import("zoop");

pub const MyClass = zoop.class(struct {
    // Fields
    allocator: std.mem.Allocator,
    value: u32,

    // Methods
    pub fn init(allocator: std.mem.Allocator, value: u32) MyClass {
        return .{
            .allocator = allocator,
            .value = value,
        };
    }

    pub fn deinit(self: *MyClass) void {
        _ = self;
    }

    pub fn getValue(self: *const MyClass) u32 {
        return self.value;
    }
});
```

**Generated**: Plain `struct` with all methods copied

---

### Mixin (Read-Only Properties)

```zig
const std = @import("std");
const zoop = @import("zoop");

pub const MyMixin = zoop.mixin(struct {
    pub const properties = .{
        .encoding = .{
            .type = []const u8,
            .access = .read_only,
        },
    };
});
```

**Generated**:
```zig
pub const MyMixin = struct {
    encoding: []const u8,

    pub inline fn get_encoding(self: *const @This()) []const u8 {
        return self.encoding;
    }
};
```

**No allocator, no init/deinit** - just the field and getter.

---

### Class with Mixin

```zig
const std = @import("std");
const zoop = @import("zoop");
const MyMixin = @import("my_mixin.zig").MyMixin;

pub const MyClass = zoop.class(struct {
    pub const mixins = .{MyMixin};

    allocator: std.mem.Allocator,

    pub fn init(allocator: std.mem.Allocator, encoding: []const u8) MyClass {
        return .{
            .allocator = allocator,
            .encoding = encoding,  // Field from mixin
        };
    }
});
```

**Generated**: Mixin fields are flattened into the class struct.

---

## Incremental Builds (Smart Caching)

Zoop uses **SHA-256 content hashing** + **timestamp checks** for fast incremental builds.

### Cache Hit (No Changes)

```bash
$ zig build
[zoop-codegen] Scanning zoop_src for class definitions...

Processed 3 files, generated 0 class files  # ‚ö° Cache hit!
[zoop-codegen] ‚úì Generated classes in src
```

**Performance**: ~50ms (just cache checks)

### Cache Miss (File Changed)

```bash
$ vim zoop_src/text_encoder.zig  # Edit file
$ zig build
[zoop-codegen] Scanning zoop_src for class definitions...
  Generated: text_encoder.zig

Processed 3 files, generated 1 class file  # Only regenerated changed file
[zoop-codegen] ‚úì Generated classes in src
```

**Performance**: ~80ms (one file regenerated)

### Clear Cache (Force Full Regeneration)

```bash
zig build clean-cache
zig build
```

**When to use**:
- After changing zoop codegen options (getter/setter prefixes)
- After updating zoop dependency
- When cache seems stale

---

## Descendant Tracking

If you change a **parent class or mixin**, zoop automatically regenerates **all descendants**.

**Example**:
```
MyMixin (changed)
  ‚Üì
MyClass (uses MyMixin)
```

**Output**:
```
Processed 2 files, generated 2 class files
```

Both `MyMixin` and `MyClass` are regenerated.

---

## WebIDL Bindings Workflow

### Overview

```
encoding.idl (WebIDL)
    ‚Üì webidl-parser
zoop_src/*.zig (Zoop source)
    ‚Üì zoop-codegen (automatic via zig build)
src/*.zig (Final Zig code)
    ‚Üì zig compiler
Compiled library
```

### Step 1: Write WebIDL

**File**: `encoding.idl`

```webidl
interface mixin TextEncoderCommon {
  readonly attribute DOMString encoding;
};

[Exposed=*]
interface TextEncoder {
  constructor();
  [NewObject] Uint8Array encode(optional USVString input = "");
};
TextEncoder includes TextEncoderCommon;
```

### Step 2: Generate Zoop Source (webidl-parser)

```bash
../webidl-parser/zig-out/bin/webidl-parser encoding.idl
mv webidl_parsed/*.zig zoop_src/
```

**Generated** (`zoop_src/text_encoder.zig`):
```zig
const std = @import("std");
const zoop = @import("zoop");

pub const TextEncoder = zoop.class(struct {
    pub const mixins = .{TextEncoderCommon};

    pub fn call_encode(self: *TextEncoder, input: ?[]const u8) []u8 {
        _ = self;
        _ = input;
        @panic("not implemented");
    }
});
```

### Step 3: Implement Methods

**Edit** `zoop_src/text_encoder.zig`:

Replace `@panic("not implemented")` with real implementation:

```zig
pub fn encode(self: *TextEncoder, input: []const u8) ![]u8 {
    // Fast path: ASCII
    if (isAscii(input)) {
        return self.allocator.dupe(u8, input);
    }

    // Full UTF-8 validation and encoding
    // ... (your implementation)
}
```

### Step 4: Build (Auto-Generates src/)

```bash
zig build
```

### Step 5: Test

```bash
zig build test
```

### Step 6: Commit Both

```bash
git add zoop_src/text_encoder.zig src/text_encoder.zig
git commit -m "Implement TextEncoder.encode()"
```

---

## Common Mistakes

### ‚ùå Mistake 1: Editing Generated Files

```bash
vim src/text_encoder.zig  # ‚ùå WRONG! This file is auto-generated
```

**Fix**: Edit `zoop_src/text_encoder.zig` instead

---

### ‚ùå Mistake 2: Not Committing Generated Files

```bash
git add zoop_src/text_encoder.zig
git commit  # ‚ùå WRONG! Missing src/text_encoder.zig
```

**Fix**: Commit both:
```bash
git add zoop_src/text_encoder.zig src/text_encoder.zig
git commit
```

---

### ‚ùå Mistake 3: Forgetting to Rebuild After Editing

```bash
vim zoop_src/text_encoder.zig
zig build test  # ‚ùå WRONG! Didn't run `zig build` first
```

**Fix**: Build first (codegen runs automatically):
```bash
vim zoop_src/text_encoder.zig
zig build        # ‚úÖ Regenerates src/text_encoder.zig
zig build test   # ‚úÖ Now tests run against updated code
```

---

### ‚ùå Mistake 4: Manual Codegen Commands

```bash
zoop-codegen --source-dir zoop_src --output-dir src  # ‚ùå WRONG! Use build system
```

**Fix**: Use `zig build` (codegen is integrated):
```bash
zig build  # ‚úÖ Automatic codegen before compilation
```

---

## Debugging Generated Code

### View What Was Generated

```bash
cat src/text_encoder.zig
```

### Compare Source vs Generated

```bash
diff zoop_src/text_encoder.zig src/text_encoder.zig
```

Shows what zoop transformed.

### Check Cache State

```bash
cat .zig-cache/zoop-manifest.json | jq .
```

Shows hashes, timestamps, class names, parent names.

---

## Build System Integration

### build.zig Setup

```zig
const std = @import("std");

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    const zoop_dep = b.dependency("zoop", .{
        .target = target,
        .optimize = optimize,
    });

    // Get zoop-codegen executable
    const zoop_exe = zoop_dep.artifact("zoop-codegen");
    const zoop = zoop_dep.module("zoop");

    // Set up automatic codegen
    const zoop_codegen_step = b.addRunArtifact(zoop_exe);
    zoop_codegen_step.addArgs(&.{
        "--source-dir", "zoop_src",
        "--output-dir", "src",
        "--getter-prefix", "get_",
        "--setter-prefix", "set_",
    });

    // Library
    const lib = b.addStaticLibrary(.{
        .name = "encoding",
        .root_source_file = b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
    });

    // IMPORTANT: Codegen runs before compilation
    lib.step.dependOn(&zoop_codegen_step.step);
    lib.root_module.addImport("zoop", zoop);

    b.installArtifact(lib);
}
```

**Key points**:
- `zoop_codegen_step` runs before `lib.step`
- Codegen is automatic (no manual commands)
- Uses local or remote zoop dependency

---

## Local vs Remote Zoop Dependency

### Remote (Published Version)

**build.zig.zon**:
```zig
.dependencies = .{
    .zoop = .{
        .url = "https://github.com/zig-whatwg/zoop/archive/refs/tags/v0.1.0.tar.gz",
        .hash = "zoop-0.1.0-N02yosnzAgC-r1gCePRwqsr5siY5rpe2dTZyYZjqBu_3",
    },
},
```

**Use when**: Using stable zoop version in production

---

### Local (Development Version)

**build.zig.zon**:
```zig
.dependencies = .{
    .zoop = .{
        .path = "../zoop",
    },
},
```

**Use when**:
- Developing/debugging zoop itself
- Testing zoop fixes before publishing
- Contributing to zoop

**Benefit**: Changes to `../zoop` are immediately available (no cache issues)

---

## Performance

### Typical Build Times (50 classes)

| Scenario | Time | Files Regenerated |
|----------|------|-------------------|
| First build (cold cache) | ~200ms | 50 |
| No changes (cache hit) | ~50ms | 0 |
| 1 leaf class changed | ~80ms | 1 |
| 1 root class changed | ~150ms | 10+ (with descendants) |

**Cache overhead**: ~2-5ms to load/save manifest

**Memory**: No leaks, all allocations tracked and freed

---

## Troubleshooting

### Generated Code Doesn't Compile

1. **Check zoop source** (`zoop_src/`) - Is the source valid Zig?
2. **Clear cache**: `zig build clean-cache`
3. **Rebuild**: `zig build`
4. **Check generated file**: `cat src/myclass.zig` - Does it look correct?

### Cache Seems Stale

```bash
zig build clean-cache
zig build
```

This forces full regeneration.

### Codegen Not Running

Check `build.zig`:
- Does `lib.step.dependOn(&zoop_codegen_step.step)` exist?
- Is `zoop_exe` correctly obtained from dependency?

### Mixin Not Flattening

Check `zoop_src/myclass.zig`:
```zig
pub const mixins = .{MyMixin};  // Must be a tuple
```

Not:
```zig
pub const mixins = MyMixin;  // ‚ùå Wrong (not a tuple)
```

---

## WebIDL-Specific Patterns

### Pattern 1: Constructor with No Arguments

**WebIDL**:
```webidl
interface TextEncoder {
  constructor();
};
```

**Zoop source**:
```zig
pub fn init(allocator: std.mem.Allocator) TextEncoder {
    return .{
        .allocator = allocator,
    };
}
```

**Note**: Always take `allocator` even if WebIDL constructor has no args.

---

### Pattern 2: Optional Parameters

**WebIDL**:
```webidl
Uint8Array encode(optional USVString input = "");
```

**Zoop source**:
```zig
pub fn encode(self: *TextEncoder, input: []const u8) ![]u8 {
    // Caller provides default "" if not specified
    // ...
}
```

**Note**: Default values handled by caller, not in signature.

---

### Pattern 3: Read-Only Attributes (Constant Values)

**WebIDL**:
```webidl
interface TextEncoder {
  readonly attribute DOMString encoding;  // Always "utf-8"
};
```

**Zoop source** (no mixin needed):
```zig
pub const TextEncoder = zoop.class(struct {
    pub inline fn get_encoding(self: *const TextEncoder) []const u8 {
        _ = self;
        return "utf-8";  // Constant value
    }
});
```

**Generated**: Getter returns constant, no field needed.

---

### Pattern 4: Read-Only Attributes (Dynamic Values)

**WebIDL**:
```webidl
interface mixin TextDecoderCommon {
  readonly attribute DOMString encoding;  // Dynamic value
};
```

**Zoop source** (mixin):
```zig
pub const TextDecoderCommon = zoop.mixin(struct {
    pub const properties = .{
        .encoding = .{
            .type = []const u8,
            .access = .read_only,
        },
    };
});
```

**Generated**: Field + getter, no allocator/init/deinit.

**Class using mixin**:
```zig
pub const TextDecoder = zoop.class(struct {
    pub const mixins = .{TextDecoderCommon};

    allocator: std.mem.Allocator,

    pub fn init(allocator: std.mem.Allocator, encoding_name: []const u8) TextDecoder {
        return .{
            .allocator = allocator,
            .encoding = encoding_name,  // Set mixin field directly
        };
    }
});
```

---

### Pattern 5: Dictionary Types

**WebIDL**:
```webidl
dictionary TextEncoderEncodeIntoResult {
  unsigned long long read;
  unsigned long long written;
};
```

**Zoop source**: Just a plain struct (no `zoop.class()`):
```zig
pub const TextEncoderEncodeIntoResult = struct {
    read: u64,
    written: u64,
};
```

**No codegen needed** - dictionaries are plain structs.

---

## Summary

### Golden Rules

1. ‚úÖ **ALWAYS edit** `zoop_src/` (source of truth)
2. ‚ùå **NEVER edit** `src/` (auto-generated)
3. ‚úÖ **ALWAYS run** `zig build` (auto-regenerates)
4. ‚úÖ **ALWAYS commit both** `zoop_src/` and `src/`
5. ‚úÖ **Use cache** for fast incremental builds

### Workflow Summary

```bash
# 1. Edit source
vim zoop_src/text_encoder.zig

# 2. Build (auto-regenerates)
zig build

# 3. Test
zig build test

# 4. Review changes
git diff zoop_src/text_encoder.zig  # Your changes
git diff src/text_encoder.zig       # What zoop generated

# 5. Commit both
git add zoop_src/ src/
git commit -m "Implement TextEncoder.encode()"
```

### Key Files

- **`zoop_src/*.zig`** - ‚úÖ Edit these (source of truth)
- **`src/*.zig`** - ‚ùå Don't edit (auto-generated)
- **`.zig-cache/zoop-manifest.json`** - Cache (gitignored)
- **`build.zig`** - Includes zoop codegen step

---

**Remember**: The zoop workflow is designed for safety and efficiency. Follow it precisely, and you'll have fast incremental builds with reviewable generated code.
